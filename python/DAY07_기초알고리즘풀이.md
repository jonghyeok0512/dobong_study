# 콜라츠 규칙과 팰린드롬 수 판별 알고리즘 학습 로그

## 1. 오늘 풀어본 문제 개요

이번 학습에서는 서로 성격이 다른 두 가지 알고리즘 문제를 풀었다.

1) 콜라츠 규칙 문제  
- 하나의 숫자를 규칙에 따라 반복 변환하면서  
- 1이 될 때까지 몇 번의 연산이 수행되는지 구하는 문제

2) 팰린드롬 수 판별 문제  
- 주어진 숫자가 앞에서 읽으나 뒤에서 읽으나 같은 수인지 판별하는 문제

두 문제 모두 반복문과 조건문을 핵심으로 사용하며,  
자료형 변환과 종료 조건을 정확히 이해하는 것이 중요했다.

---

## 2. 콜라츠 규칙 문제

### 문제 핵심 규칙
- n이 짝수이면 → n / 2  
- n이 홀수이면 → n * 3 + 1  
- 이 과정을 반복하여 n이 1이 될 때까지 수행  
- 총 반복 횟수를 반환

### 최종 코드

```python
def solution(n):
    answer = 0
    while n != 1:
        if n % 2 == 0:
            n /= 2
        else:
            n = (n * 3) + 1
        answer += 1
    return answer
```

### 핵심 포인트 정리
- while문은 종료 조건이 명확할 때 사용하기 적합하다.
- n이 1이 되는 순간 반복을 멈춰야 한다.
- 짝수/홀수 판별은 나머지 연산자(%)를 사용한다.
- 반복 횟수를 세기 위해 answer 변수를 사용한다.

---

## 3. 팰린드롬 수 판별 문제

### 문제 핵심 개념
- 숫자를 문자열로 변환하면 자릿수 접근이 쉬워진다.
- 문자열 슬라이싱을 이용하면 뒤집기가 간단하다.
- 원본 문자열과 뒤집은 문자열을 비교해 결과를 판단한다.

### 최종 코드

```python
def solution(n):
    answer = True
    n = str(n)
    if n != n[::-1]:
        answer = False
    return answer
```

### 핵심 포인트 정리
- 문자열 슬라이싱 `[::-1]`은 문자열을 뒤집는 가장 간단한 방법이다.
- 조건이 만족되지 않을 경우에만 False로 변경하는 구조를 사용했다.
- 불필요한 반복문 없이 비교 연산만으로 문제를 해결했다.

---

## 4. 두 문제를 통해 배운 공통 알고리즘 개념

- 조건문(if/else)을 통한 분기 처리
- 반복문(while)을 사용한 상태 변화 추적
- 종료 조건을 명확히 설정하는 중요성
- 숫자와 문자열을 상황에 맞게 변환하는 사고 방식

---

## 5. 헷갈릴 수 있는 포인트 정리

- 콜라츠 문제에서 종료 조건을 잘못 설정하면 무한 루프에 빠질 수 있다.
- 나눗셈 연산 시 자료형 변화(int → float)에 주의해야 한다.
- 팰린드롬 문제는 문자열 변환이 가장 단순한 해결책이다.

---

## 6. 느낀 점

두 문제 모두 로직 자체는 단순하지만,  
문제를 어떻게 단순화해서 바라보느냐가 중요했다.

콜라츠 문제는 "언제 끝나는가"를 먼저 생각해야 했고,  
팰린드롬 문제는 "어떻게 비교하면 가장 쉬운가"를 고민하게 만들었다.

---

## 7. 한 줄 핵심 정리

알고리즘 문제는 복잡한 계산보다  
반복 조건과 비교 기준을 명확히 정리하는 것이 핵심이다.
