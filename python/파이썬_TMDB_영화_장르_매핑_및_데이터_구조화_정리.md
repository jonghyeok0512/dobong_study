# [2026-01-19] 알고리즘 문제풀이: TMDB 데이터 추출 및 장르 매핑

### 1. 문제 정의
- **목표**: 현재 상영 중인 영화 데이터(`now_playing`)에서 각 영화의 제목(`title`)과 그에 맞는 장르 이름들(`genres`)을 추출하여 리스트 형태로 정리한다.
- **조건**: 
    - 장르는 숫자 ID가 아닌 실제 텍스트 이름이어야 함.
    - 한 영화에 여러 장르가 있을 수 있으므로 리스트 형태(`[장르1, 장르2]`)로 저장해야 함.

### 2. 학습 포인트와 문제풀이 핵심
- **데이터 결합(Data Joining)**: 영화 목록 데이터와 장르 목록 데이터를 특정 기준(ID)으로 연결하는 방식 학습.
- **구조적 사고**: `[{제목: [장르명]}]`과 같은 복합적인 자료구조를 코드로 구현하는 능력.
- **반복문의 생명주기**: 어떤 변수가 언제 생성되고 소멸되어야 하는지(초기화 위치) 파악.

### 3. 풀이과정 리뷰
1. `get_movie_by_path`를 통해 영화 목록과 장르 목록을 각각 호출함.
2. 영화 목록(`movies`)을 순회하며 각 영화의 `title`과 `genre_ids` 리스트를 확보함.
3. 각 영화 안에서 다시 전체 장르 목록(`genres_data`)을 순회하며, 영화의 `genre_ids`에 포함된 ID가 있는지 비교함.
4. 일치하는 경우 해당 장르의 이름을 영화별 리스트에 추가함.
5. 최종적으로 완성된 영화별 딕셔너리를 전체 결과 리스트(`now_playing_genre`)에 담음.

### 4. 실수나 헤멨던 부분 리뷰
- **변수명 충돌**: `id`, `name` 등 너무 짧은 변수명을 쓰다 보니 바깥쪽 반복문의 변수와 안쪽 반복문의 변수가 섞여 로직이 꼬였음. `movie_id`, `genre_id`처럼 명확하게 이름을 지어야 함.
- **딕셔너리 초기화**: 처음에는 영화 한 편당 딕셔너리를 만드는 위치를 잘못 잡아 모든 영화 데이터가 하나로 합쳐지거나 사라지는 실수를 함.
- **메서드 오류**: 딕셔너리에 직접 `.append()`를 쓰려다 에러가 발생함. `movie_genre[title]`이라는 '리스트'에 접근해서 써야 한다는 점을 다시 확인했음.

### 5. 이번 학습으로 얻은 내용
- 복잡한 JSON 데이터를 내가 원하는 형태의 데이터 모델로 변환(Parsing)하는 감각을 익힘.
- 딕셔너리의 키(`Key`)를 변수로 활용하여 동적으로 데이터를 생성하는 법을 배움.

### 6. 코드리뷰 (한 줄 주석)
```python
# 영화와 장르 데이터를 API로부터 가져옴
data = get_movie_by_path(f"movie/now_playing")
genres_data = get_movie_by_path(f"genre/movie/list")
genres_data = genres_data['genres'] # 장르 리스트만 추출
movies = data['results'] # 영화 리스트만 추출

# 최종 결과를 담을 리스트 (전역 공간)
now_playing_genre = []

for movie in movies:
    # 각 영화마다 장르 ID 리스트와 제목을 미리 뽑아둠
    genre_ids = movie['genre_ids']
    title = movie['title'] 
    
    # 영화 한 편의 결과를 담을 딕셔너리 초기화 (영화마다 새로 생성)
    # 제목을 키로 하고, 장르들을 담을 빈 리스트를 값으로 설정
    movie_genre = {title: []}
    
    for genre_data in genres_data: 
        # 장르 데이터 세트에서 ID와 이름을 확인
        target_id = genre_data['id']
        target_name = genre_data['name']
        
        # 만약 영화가 가진 장르 ID 목록에 이 장르 ID가 포함되어 있다면
        if target_id in genre_ids:
            # 딕셔너리 내부의 리스트에 장르 이름을 추가
            movie_genre[title].append(target_name)
            
    # 영화 한 편의 조사가 끝나면 전체 리스트에 최종 딕셔너리 삽입
    now_playing_genre.append(movie_genre)

# 결과 출력
pprint(now_playing_genre)
```
- **시간 복잡도**: 영화의 개수를 $N$, 전체 장르의 개수를 $M$이라 할 때 $O(N \times M)$의 시간이 걸림.
- **성능 리뷰**: 현재 데이터 양이 적어 문제가 없지만, 실무에서 수만 건의 데이터를 다룰 때는 장르 데이터를 미리 `{ID: 이름}` 형태의 딕셔너리로 만들어두면 안쪽 반복문 없이 바로 찾을 수 있어 성능이 $O(N)$으로 개선됨.

### 7. 실무관점의 참견 적용해보기
- **명시적인 변수명**: 실무에서는 `id`, `name` 같은 일반적인 이름은 지양함. `genre_id`, `movie_title` 등으로 명확히 구분해야 팀원들이 코드를 읽을 때 오해가 없음.
- **에러 핸들링**: 만약 API 응답 중에 `genre_ids`가 아예 없는 영화가 섞여 들어온다면 코드가 멈출 수 있음. `movie.get('genre_ids', [])` 처럼 기본값을 주는 방식을 쓰면 더 안전한 코드가 됨.
- **RAG 데이터 활용**: 이렇게 텍스트로 변환된 장르 데이터는 나중에 사용자가 "액션 영화 추천해줘"라고 했을 때, AI가 해당 영화를 '액션' 범주에서 검색할 수 있게 만드는 핵심 메타데이터가 됨.