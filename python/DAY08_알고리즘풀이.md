# 오늘 배운 내용 정리

## 1. 이차원 배열과 2×2 서브블록

### 이차원 배열 기본
- 이차원 배열은 리스트 안에 리스트 구조이다.
- 값 하나에 접근할 때는 반드시 [행][열] 형태로 접근한다.

예시:
array[i][j]

### n, m의 의미
- n = 행의 개수
- m = 열의 개수

### 2×2 서브블록 반복 범위
- 2×2를 만들기 위해 i+1, j+1을 사용하므로
- 반복문 범위는 range(n-1), range(m-1)을 사용해야 한다.

### 2×2 합 계산
- (i, j)를 기준으로 아래 4칸을 더한다.
- array[i][j]
- array[i][j+1]
- array[i+1][j]
- array[i+1][j+1]

---

## 2. max / min 초기값 설정 이유

### 왜 0으로 하면 안 되는가
- 배열 원소가 음수가 될 수 있기 때문에
- 실제 최대값이 음수인 경우 0은 잘못된 결과가 된다.

### 안전한 초기값 설정
- max_sum은 충분히 작은 값으로
- min_sum은 충분히 큰 값으로 설정한다.

이유:
- 첫 비교에서 무조건 실제 값으로 갱신되도록 하기 위함

---

## 3. 팰린드롬(Palindrome) 개념

### 팰린드롬 정의
- 앞에서 읽어도 뒤에서 읽어도 같은 값

### 숫자 팰린드롬 풀이 핵심
- 숫자는 바로 뒤집을 수 없으므로 문자열로 변환
- 문자열을 뒤집어서 비교

핵심 로직:
- str(n) == str(n)[::-1]

---

## 4. set 자료구조

### set의 특징
- 중복 제거
- 순서 없음
- in 연산이 매우 빠름 (O(1))

### 리스트 vs set
- 포함 여부 검사(in)는 set이 훨씬 효율적
- 순서가 필요하면 list 사용

---

## 5. 최빈값(Mode)

### 최빈값 정의
- 가장 많이 등장한 값

### 문제 핵심 조건
- 최빈값이 여러 개면 가장 작은 수 반환

### 문제 해결 흐름
1. set(numbers)로 후보 숫자 생성
2. 각 숫자의 등장 횟수를 count()로 계산
3. 최대 등장 횟수와 비교
4. 횟수가 같으면 숫자 크기 비교

### 최종 로직 핵심
- 값과 횟수를 반드시 같이 관리해야 함
- if / elif로 겹치지 않는 조건 분기 필요
